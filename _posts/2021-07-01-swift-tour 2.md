---
title: Dando un Tour por el lenguaje Swift
category: Swift
layout: post
---

Suponiendo que esta sea la primera vez que tendrás un acercamiento con el lenguaje de programación Swift, la tradición dice que el primer programa que debes escribir cuando te inicias en un lenguaje de programación sería imprimir las palabras "Hello World!" en pantalla. Esto en Swift es muy sencillo, y bastaría con escribir la siguiente línea de código:

```
print("Hello World!")
//Esta línea imprime -> Hello World!
```

Si alguna vez has escrito código en lenguaje C o en Objective-C, esta sintaxis será bastante familiar para ti - en Swift, esa última línea de código, se puede decir que es un programa completo. No necesitas importar una biblioteca por separado para agregar funcionalidad como de entrada/salida o manejo de cadenas. El código escrito a Scope global es utilizado como punto de entrada para el programa, entonces, tampoco necesitas una función main(). Inclusive tampoco necesitas agregar el clásico ";" al final de cada sentencia.

Este tour te va a dar la suficiente información para empezar a escribir código en Swift mostrándote cómo lograr una variedad de tareas sobre programación. No te preocupes si algo no queda 100% claro - todo lo que se vea aquí se puede mostrar y trabajar también en el resto de esta Wiki.

---
Simple Values (Valores Simples)
--- 

Usa la palabra reervada "let" para crear una constante y "var" para crear una variable. El valor de la constante no necesita ser reconocida en tiempo de compilación, pero si al menos necesitas asignarle un valor. Esto significa que puedes usar a las constantes para nombrar a un valor que acabas de determinar pero también usar en varios lugares.

```
var myVariable = 42
myVariable = 50
let myConstant = 42
```

Una constante o variable debe tener el mismo tipo que el valor que deseas asignarle. Sin embargo, no siempre es necesario escribir el tipo de forma explícita. Proporcionar un valor cuando se crea una constante o variable permite al compilador inferir su tipo. En el ejemplo anterior, el compilador infiere que myVariable es un número entero porque su valor inicial es, valga la redundancia, un número entero.

Si el valor inicial no proporciona suficiente información (o si no es un valor inicial), hay que especificar el tipo escribiéndolo después de la variable, separados por dos puntos. 

```
let implicitInteger = 70
let implicitDouble = 70.0
let explicitDouble: Double = 70
```

---
Control Flow (Flujo de control)
---

Utiliza las palabras reservadas if y switch para hacer condicionales, y utiliza for-in, while y repeat-while para hacer bucles. Los paréntesis alrededor de la condición o variable de ciclo son opcionales. Se requieren llaves "{ }" alrededor del cuerpo.

```
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score > 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
print(teamScore)
// Imprime "11"
```

En una declaración if (O if statement e inglés), el condicional debe ser una expresión booleana; esto significa que un código como "if score {...}" es un error, no una comparación implícita con cero.

Puedes utilizar if y let juntos para trabajar con valores que puedan faltar. Estos valores se representan como opcionales. Un valor opcional contiene un valor o contiene nil para indicar que falta un valor. Puedes escribir un signo de interrogación (?) Después del tipo de valor para marcar el valor como opcional.

```
var optionalString: String? = "Hello"
print(optionalString == nil)
// Imprime "false"

var optionalName: String? = "John Appleseed"
var greeting = "Hello!"
if let name = optionalName {
    greeting = "Hello, \(name)"
}
```

Si el valor opcional es nulo, el condicional es falso y se omite el código entre llaves. De lo contrario, el valor opcional se desenvuelve y se asigna a la constante después de let, lo que hace que el valor desenvuelto esté disponible dentro del bloque de código.

Otra forma de manejar valores opcionales es proporcionar un valor predeterminado usando el operador ??. Si falta el valor opcional, se utiliza el valor predeterminado en su lugar.

```
let nickname: String? = nil
let fullName: String = "John Appleseed"
let informalGreeting = "Hi \(nickname ?? fullName)"
```

Los "switch" admiten cualquier tipo de datos y una amplia variedad de operaciones de comparación; no se limitan a números enteros y pruebas de igualdad.

```
let vegetable = "red pepper"
switch vegetable {
case "celery":
    print("Add some raisins and make ants on a log.")
case "cucumber", "watercress":
    print("That would make a good tea sandwich.")
case let x where x.hasSuffix("pepper"):
    print("Is it a spicy \(x)?")
default:
    print("Everything tastes good in soup.")
}
// Imprime "Is it a spicy red pepper?"
```

Observa cómo se puede usar let en un patrón para asignar el valor que coincide con el patrón a una constante.

Después de ejecutar el código dentro del caso del switch que coincidió, el programa sale de la declaración del switch. La ejecución no continúa con el siguiente caso, por lo que no es necesario salir explícitamente del switch al final del código de cada caso.

Se usa "for-in" para iterar sobre elementos en un diccionario proporcionando un par de nombres para usar para cada par clave-valor. Los diccionarios son una colección desordenada, por lo que sus claves y valores se repiten en un orden arbitrario.

```
let interestingNumbers = [
    "Prime": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Square": [1, 4, 9, 16, 25],
]
var largest = 0
for (_, numbers) in interestingNumbers {
    for number in numbers {
        if number > largest {
            largest = number
        }
    }
}
print(largest)
// Imprime "25"
```

Utiliza un "while" para repetir un bloque de código hasta que alguna condición cambie. La condición de un bucle puede estar al final, asegurando así que el bucle va a ser ejecutado al menos una vez.

```
var n = 2
while n < 100 {
    n *= 2
}
print(n)
// Prints "128"

var m = 2
repeat {
    m *= 2
} while m < 100
print(m)
// Imprime "128"
```

También, puedes mantener un índice en un bucle usando "..<" para hacer un rango de índices.

```
var total = 0
for i in 0..<4 {
    total += i
}
print(total)
// Imprime "6"
```

Utiliza "..<" para hacer un rango que omita su valor superior y utiliza "..." para hacer un rango que incluya ambos valores.

---
Functions and Closures (Funciones y Closures)
--- 

Utiliza "func" para declarar una función. Se llama a una función siguiendo su nombre con una lista de argumentos entre paréntesis. Utiliza "->" para separar los nombres y tipos de parámetros del tipo de retorno de la función.

```
func greet(person: String, day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet(person: "Bob", day: "Tuesday")
```

De forma predeterminada, las funciones utilizan los nombres de sus parámetros como etiquetas para sus argumentos. Escribe una etiqueta de argumento personalizada antes del nombre del parámetro, o escribe _ para no usar una etiqueta de argumento.

```
func greet(_ person: String, on day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
```

Utilice una tupla para crear un valor compuesto, por ejemplo, para devolver varios valores de una función. Se puede hacer referencia a los elementos de una tupla por su nombre o por número.

```
func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0

    for score in scores {
        if score > max {
            max = score
        } else if score < min {
            min = score
        }
        sum += score
    }

    return (min, max, sum)
}
let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])
print(statistics.sum)
// Prints "120"
print(statistics.2)
// Prints "120"
```

Las funciones se pueden anidar. Las funciones anidadas tienen acceso a las variables que se declararon en la función externa. Puedes utilizar funciones anidadas para organizar el código en una función que sea larga o compleja.

```
func returnFifteen() -> Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
```

Las funciones son de primera clase. Esto significa que una función puede devolver otra función como su valor.

```
func makeIncrementer() -> ((Int) -> Int) {
    func addOne(number: Int) -> Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
```

Una función puede tomar otra función como uno de sus argumentos.

```
func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -> Bool {
    return number < 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
```

Las funciones son en realidad un caso especial de "closures": bloques de código que se pueden llamar más tarde. El código en un "closure" tiene acceso a cosas como variables y funciones que estaban disponibles en el alcance donde se creó el "closure", incluso si el "closure" está en un alcance diferente cuando se ejecuta; ya vimos un ejemplo de esto con funciones anidadas. Puedes escribir un "closure" sin un nombre rodeando el código con llaves ({}). Úsalo para separar los argumentos y el tipo de retorno del cuerpo.

```
numbers.map({ (number: Int) -> Int in
    let result = 3 * number
    return result
})
```

Tienes varias opciones para escribir "closures" de forma más concisa. Cuando ya se conoce el tipo de un "closure", como la devolución de llamada de un delegado, puedes omitir el tipo de sus parámetros, su tipo de retorno o ambos. Los "closures" de declaración única devuelven implícitamente el valor de su única declaración.

```
let mappedNumbers = numbers.map({ number in 3 * number })
print(mappedNumbers)
// Imprime "[60, 57, 21, 36]"
```

Puedes hacer referencia a los parámetros por número en lugar de por nombre; este enfoque es especialmente útil en closures muy cortos. Un closure pasado como último argumento de una función puede aparecer inmediatamente después del paréntesis. Cuando un closure es el único argumento de una función, puede omitir los paréntesis por completo.

```
let sortedNumbers = numbers.sorted { $0 > $1 }
print(sortedNumbers)
// Imprime "[20, 19, 12, 7]"
```

---
Objects and Classes (Objetos y clases)
---

Usa "class" seguido del nombre de la clase para crear, si, en efecto, una clase. Una declaración de propiedad en una clase se escribe de la misma manera que una declaración de constante o variable, excepto que está en el contexto de una clase. Asimismo, las declaraciones de métodos y funciones se escriben de la misma manera.

```
class Shape {
    var numberOfSides = 0
    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}
```

Puedes crear una instancia de una clase poniendo paréntesis después del nombre de la clase. Utilice la sintaxis de puntos para acceder a las propiedades y métodos de la instancia.

```
var shape = Shape()
shape.numberOfSides = 7
var shapeDescription = shape.simpleDescription()
```

A esta versión de la clase Shape le falta algo importante: un inicializador para configurar la clase cuando se crea una instancia. Utiliza "init" para crear uno.

```
class NamedShape {
    var numberOfSides: Int = 0
    var name: String

    init(name: String) {
        self.name = name
    }

    func simpleDescription() -> String {
        return "A shape with \(numberOfSides) sides."
    }
}
```

Observa cómo se usa self para distinguir la propiedad del nombre del argumento del nombre al inicializador. Los argumentos del inicializador se pasan como una llamada de función cuando creas una instancia de la clase. Cada propiedad necesita un valor asignado, ya sea en su declaración (como con numberOfSides) o en el inicializador (como con name).

Utiliza deinit para crear un desinicializador si necesitas realizar alguna limpieza antes de que se desasigne el objeto.

Las subclases incluyen su nombre de superclase después de su nombre de clase, separados por dos puntos. No hay ningún requisito para que las clases subclasifiquen cualquier clase raíz estándar, por lo que puedes incluir u omitir una superclase según sea necesario.

Los métodos de una subclase que anulan la implementación de la superclase se marcan con anulación: anular un método por accidente, sin anulación, es detectado por el compilador como un error. El compilador también detecta métodos con anulación que en realidad no anulan ningún método en la superclase.

```
class Square: NamedShape {
    var sideLength: Double

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 4
    }

    func area() -> Double {
        return sideLength * sideLength
    }

    override func simpleDescription() -> String {
        return "A square with sides of length \(sideLength)."
    }
}
let test = Square(sideLength: 5.2, name: "my test square")
test.area()
test.simpleDescription()
```

Además de las propiedades simples que se almacenan, las propiedades pueden tener un captador y un definidor.

```
class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0

    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }

    var perimeter: Double {
        get {
            return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }

    override func simpleDescription() -> String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
print(triangle.perimeter)
// Imprime "9.3"
triangle.perimeter = 9.9
print(triangle.sideLength)
// Imprime "3.3000000000000003"
```

En el setter de perímetro, el nuevo valor tiene el nombre implícito newValue. Puedes proporcionar un nombre explícito entre paréntesis después del conjunto.

Observa que el inicializador de la clase EquilateralTriangle tiene tres pasos diferentes:

1.- Establecer el valor de las propiedades que declara la subclase.
2.- Llamando al inicializador de la superclase.
3.- Cambiar el valor de las propiedades definidas por la superclase. En este punto, también se puede realizar cualquier trabajo de configuración adicional que utilice métodos, getters o setters.

Si no necesitas calcular la propiedad, pero aún necesitas proporcionar un código que se ejecute antes y después de establecer un nuevo valor, utiliza willSet y didSet. El código que proporcionas se ejecuta cada vez que el valor cambia fuera de un inicializador. Por ejemplo, la siguiente clase asegura que la longitud del lado de su triángulo sea siempre la misma que la longitud del lado de su cuadrado.

```
class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
print(triangleAndSquare.square.sideLength)
// Imprime "10.0"
print(triangleAndSquare.triangle.sideLength)
// Imprime "10.0"
triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
print(triangleAndSquare.triangle.sideLength)
// Imprime "50.0"
```

Cuando trabajas con valores opcionales, puedes escribir "?" antes de operaciones como métodos, propiedades y subíndices. Si el valor antes de "?" es nulo, todo después del "?" se ignora y el valor de toda la expresión es nulo. De lo contrario, el valor opcional se desenvuelve y todo lo que sigue a "?" actúa sobre el valor sin envolver. En ambos casos, el valor de toda la expresión es un valor opcional.

```
let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
let sideLength = optionalSquare?.sideLength
```

---
Enumerations and Structures (Enumeraciones y Estructuras)
---

Utiliza "enum" para crear una enumeración. Al igual que las clases y todos los demás tipos con nombre, las enumeraciones pueden tener métodos asociados.

```
enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king

    func simpleDescription() -> String {
        switch self {
        case .ace:
            return "ace"
        case .jack:
            return "jack"
        case .queen:
            return "queen"
        case .king:
            return "king"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
```

De forma predeterminada, Swift asigna los valores brutos (raw values) comenzando en cero y aumentando en uno cada vez, pero puedes cambiar este comportamiento especificando valores explícitamente. En el ejemplo anterior, a Ace se le da explícitamente un valor raw de 1, y el resto de los valores raw se asignan en orden. También puedes utilizar cadenas o números de punto flotante como el tipo sin formato de una enumeración. Utiliza la propiedad rawValue para acceder al valor raw de un caso de enumeración.

Utiliza el inicializador init?(rawValue :) para crear una instancia de una enumeración a partir de un valor sin procesar. Devuelve el caso de enumeración que coincide con el valor sin procesar o nulo si no hay ningún Rango coincidente.

```
if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
```

Los valores de caso de una enumeración son valores reales, no solo otra forma de escribir sus valores brutos (raw values). De hecho, en los casos en los que no existe un valor raw significativo, no es necesario que proporcione uno.

```
enum Suit {
    case spades, hearts, diamonds, clubs

    func simpleDescription() -> String {
        switch self {
        case .spades:
            return "spades"
        case .hearts:
            return "hearts"
        case .diamonds:
            return "diamonds"
        case .clubs:
            return "clubs"
        }
    }
}
let hearts = Suit.hearts
let heartsDescription = hearts.simpleDescription()
```

Observa las dos formas en que se hace referencia al caso de corazones de la enumeración anteriormente: cuando se asigna un valor a la constante de corazones, el caso de enumeración Suit.hearts se denomina por su nombre completo porque la constante no tiene un tipo explícito especificado. Dentro del switch, el caso de enumeración se conoce con la forma abreviada .hearts porque ya se sabe que el valor de uno mismo es un traje. Puede utilizar la forma abreviada siempre que se conozca el tipo del valor.

Si una enumeración tiene valores sin procesar, esos valores se determinan como parte de la declaración, lo que significa que cada instancia de un caso de enumeración en particular siempre tiene el mismo valor sin procesar. Otra opción para los casos de enumeración es tener valores asociados con el caso; estos valores se determinan cuando crea la instancia y pueden ser diferentes para cada instancia de un caso de enumeración. Podrías pensar que los valores asociados se comportan como propiedades almacenadas de la instancia del caso de enumeración. Por ejemplo, considera el caso de solicitar las horas de salida y puesta del sol a un servidor. El servidor responde con la información solicitada o responde con una descripción de lo que salió mal.

```
enum ServerResponse {
    case result(String, String)
    case failure(String)
}

let success = ServerResponse.result("6:00 am", "8:09 pm")
let failure = ServerResponse.failure("Out of cheese.")

switch success {
case let .result(sunrise, sunset):
    print("Sunrise is at \(sunrise) and sunset is at \(sunset).")
case let .failure(message):
    print("Failure...  \(message)")
}
// Imprime "Sunrise is at 6:00 am and sunset is at 8:09 pm."
```

Observa cómo las horas de salida y puesta del sol se extraen del valor ServerResponse como parte de la comparación del valor con los casos de cambio.

Usa struct para crear una estructura. Las estructuras admiten muchos de los mismos comportamientos que las clases, incluidos los métodos y los inicializadores. Una de las diferencias más importantes entre estructuras y clases es que las estructuras siempre se copian cuando se pasan en su código, pero las clases se pasan por referencia.

```
struct Card {
    var rank: Rank
    var suit: Suit
    func simpleDescription() -> String {
        return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
    }
}
let threeOfSpades = Card(rank: .three, suit: .spades)
let threeOfSpadesDescription = threeOfSpades.simpleDescription()
```

---
Protocols and Extensions (Protocolos y Extensiones)
---

Usa "protocol" para declarar un protocolo.

```
protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
```

Las clases, enums o structs, todos ellos pueden adoptar (o mas bien conformar) a un protocolo.

```
class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription

struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
```

Observa el uso de la palabra clave "mutating" en la declaración de SimpleStructure para marcar un método que modifica la estructura. La declaración de SimpleClass no necesita que ninguno de sus métodos esté marcado como mutating porque los métodos de una clase siempre pueden modificar la clase.

Utiliza "extension" para agregar funcionalidad a un tipo existente, como nuevos métodos y propiedades calculadas. Puede usar una extensión para agregar conformidad de protocolo a un tipo que se declara en otro lugar, o incluso a un tipo que ha importado de una biblioteca o marco.

```
extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)
// Imprime "The number 7"
```

Puedes usar un nombre de protocolo como cualquier otro tipo con nombre, por ejemplo, para crear una colección de objetos que tengan diferentes tipos pero que se ajusten a un solo protocolo. Cuando trabajas con valores cuyo tipo es un tipo de protocolo, los métodos fuera de la definición del protocolo no están disponibles.

```
let protocolValue: ExampleProtocol = a
print(protocolValue.simpleDescription)
// Imprime "A very simple class.  Now 100% adjusted."
// print(protocolValue.anotherProperty)  // Descomenta esta linea para ver el error
```

Aunque la variable protocolValue tiene un tipo de tiempo de ejecución de SimpleClass, el compilador la trata como el tipo dado de ExampleProtocol. Esto significa que no puede acceder accidentalmente a métodos o propiedades que la clase implementa además de su conformidad con el protocolo.

---
Error Handling (Manejo de Errores)
---

Puedes representar errores utilizando cualquier tipo que se conforme al protocolo Error.

```
enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}
```

Utiliza throw para lanzar un error y throws para marcar una función que puede lanzar un error. Si arroja un error en una función, la función regresa inmediatamente y el código que llamó a la función maneja el error.

```
func send(job: Int, toPrinter printerName: String) throws -> String {
    if printerName == "Never Has Toner" {
        throw PrinterError.noToner
    }
    return "Job sent"
}
```

Hay varias formas de manejar los errores. Una forma es utilizar "do-catch". Dentro del bloque do, marca el código que puede arrojar un error escribiendo try delante de él. Dentro del bloque de captura, al error se le asigna automáticamente el nombre error a menos que le dé un nombre diferente.

```
do {
    let printerResponse = try send(job: 1040, toPrinter: "Bi Sheng")
    print(printerResponse)
} catch {
    print(error)
}
// Imprime "Job sent"
```

Puedes proporcionar varios bloques de captura que manejen errores específicos. Escribes un patrón después de la captura tal como lo haces después de un caso en un interruptor.

```
do {
    let printerResponse = try send(job: 1440, toPrinter: "Gutenberg")
    print(printerResponse)
} catch PrinterError.onFire {
    print("I'll just put this over here, with the rest of the fire.")
} catch let printerError as PrinterError {
    print("Printer error: \(printerError).")
} catch {
    print(error)
}
// Imprime "Job sent"
```

Otra forma de manejar los errores es usar "try?" para convertir el resultado en opcional. Si la función arroja un error, el error específico se descarta y el resultado es nulo. De lo contrario, el resultado es un opcional que contiene el valor que devolvió la función.

```
let printerSuccess = try? send(job: 1884, toPrinter: "Mergenthaler")
let printerFailure = try? send(job: 1885, toPrinter: "Never Has Toner")
```

Utilice "defer" para escribir un bloque de código que se ejecute después de todos los demás códigos en la función, justo antes de que la función regrese. El código se ejecuta independientemente de si la función arroja un error. Puede usar "defer" para escribir el código de configuración y limpieza uno al lado del otro, aunque deben ejecutarse en momentos diferentes.

```
var fridgeIsOpen = false
let fridgeContent = ["milk", "eggs", "leftovers"]

func fridgeContains(_ food: String) -> Bool {
    fridgeIsOpen = true
    defer {
        fridgeIsOpen = false
    }

    let result = fridgeContent.contains(food)
    return result
}
fridgeContains("banana")
print(fridgeIsOpen)
// Imprime "false"
```

---
Generics (Genericos)
---

Escribe un nombre entre corchetes angulares para hacer una función o tipo genérico.

```
func makeArray<Item>(repeating item: Item, numberOfTimes: Int) -> [Item] {
    var result: [Item] = []
    for _ in 0..<numberOfTimes {
        result.append(item)
    }
    return result
}
makeArray(repeating: "knock", numberOfTimes: 4)
```

Puedes hacer formas genericas de funciones y métodos, así como tambien de clases, enums y estructuras.

```
// Reimplementa a la biblioteca optional type estandar de Swift
enum OptionalValue<Wrapped> {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue<Int> = .none
possibleInteger = .some(100)
```

Usa "where" justo antes del cuerpo para especificar una lista de requisitos, por ejemplo, para requerir que el tipo implemente un protocolo, para requerir que dos tipos sean iguales o para requerir que una clase tenga una superclase en particular.

```
func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool
    where T.Element: Equatable, T.Element == U.Element
{
    for lhsItem in lhs {
        for rhsItem in rhs {
            if lhsItem == rhsItem {
                return true
            }
        }
    }
    return false
}
anyCommonElements([1, 2, 3], [3])
```

Escribir <T: Equatable> es lo mismo que escribir <T> ... where T: Equatable.

---
## Recursos
- [The Swift Programming Language](https://docs.swift.org/swift-book/GuidedTour/GuidedTour.html) : Libro que da el tour completo sobre el lenguaje de programación Swift en formato web.
